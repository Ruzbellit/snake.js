<canvas id="canvas" width="300" height="300"></canvas>
<script src="web-lib/processing.js"></script>
<script src="web-lib/fl-extended.js"></script>
<script>
  //Vamos a usar http://processingjs.org/
  // o https://p5js.org/reference/

  // Importamos las librerias
  let { append, cons, first, isEmpty, isList, length, rest, map } = require("fl-extended");

  function apply(a, f) {
    if (!isEmpty(a)) {
      f(first(a));
      apply(rest(a), f);
    }
  }

  function moveSnake(snake, dir) {
    const head = first(snake);
    return cons({ x: head.x + dir.x, y: head.y + dir.y }, snake.slice(0, length(snake) - 1));
  }

  // Retorna un entero aleatorio entre min (incluido) y max (excluido)
  function getRandomInt(min, max) {
    return Math.floor(Math.random() * (max - min)) + min;
  }

  /**generateFood: this function randomly generate the food on the canvas
   *@return: position 
   *@example: x: 13, y: 7
   */
  function generateFood() {
    return { x: getRandomInt(0, 20), y: getRandomInt(0, 20) };
  }

  /**eatFood this function verify if the food and the snake’s head are in the same position,
   *if so it returns the world with a new position for the food and an adicional part on the snake.
   *@param: object
   *@return object
   */
  function eatFood(world) {
    const head = first(world.snake);
    if (head.x == world.food.x && head.y == world.food.y) {
      // si la cabeza está sobre la comida
      return make(world, {
        snake: cons({ x: head.x + world.dir.x, y: head.y + world.dir.y }, world.snake),
        food: generateFood(),
        score: world.score + 10
      });
    }
    return make(world, {});
  }

  function eatLife(world) {
    if (world.l === true) {
      const head = first(world.snake);
      if (head.x == world.life.x && head.y == world.life.y) {
        // si la cabeza está sobre la comida
        return make(world, {
          life: generateFood(),
          vida: world.vida + 1,
          score: world.score + 10,
          l: false
        });
      }
      return make(world, {});
    } else {
      return make(world, {});
    }
  }
function score(world){
  if(world.score % 100 == 0){
    return make(world,{l: true})
  }else{
    return make(world, {})
  }
}
  /*collision: establece los limites de colision del mapa, y al estrellarse resta una vida
  *@param: object
  *@return: object
  */
  function collision(world) {
    if ((first(world.snake).x >= 0 && first(world.snake).x <= 19) && (first(world.snake).y >= 0 && first(world.snake).y <= 19)) {
      return make(world, {})    //Limita el espacio de la serpientita, se muere y hace pum!
    } else {
      if (world.vida == 0) {
        alert("Game over")
      } else {
        return make(world, { snake: world.snake1, dir: { x: 1, y: 0 }, vida: world.vida - 1, speed: 5, score: 10, food: generateFood() })
      }
    }
  }

  /**toggleNitro: this function change the speed if is 5 change to 15 and vice versa
  *@param: number
  *@return: number
  *@example: toggleNitro(5) -> 15
  */
  function toggleNitro(speed) {
    if (speed == 5) {
      return 10;
    } else {
      return 5;
    }
  }

  const dx = 40;
  const dy = 40;

  function make(data, attribute) {
    return Object.assign({}, data, attribute);
  }

  function sketchProc(processing) {
    /**
     * Esto se llama antes de iniciar el juego
     */
    processing.setup = function () {
      processing.size(800, 800);
      processing.background(255, 153, 255);
      processing.state = {
        snake1: [{ x: 3, y: 1 }, { x: 2, y: 1 }, { x: 1, y: 1 }],
        snake: [{ x: 3, y: 1 }, { x: 2, y: 1 }, { x: 1, y: 1 }],
        dir: { x: 1, y: 0 },
        food: { x: generateFood().x, y: generateFood().y },
        life: { x: 10, y: 8 },
        speed: 5,
        score: 10,
        vida: 3,
        l: false
      };
      fondo = processing.loadImage('data/fondo/ground.png');
      comida = processing.loadImage('data/comida/food.png');
      life = processing.loadImage('data/especiales/God.png');
      skin = processing.loadImage('data/01.png')
    }

    // Dibuja algo en el canvas. Aqui se pone todo lo que quieras pintar
    processing.drawGame = function (world) {
      processing.background(255, 153, 255);
      processing.image(fondo, 0, 0, 800, 800);

      // Establece la velocidad
      processing.frameRate(world.speed);

      // Pinta la culebrita
      processing.fill(153, 204, 255);
      apply(world.snake, s => {
        processing.image(skin, s.x * dx, s.y * dy, dx, dy);
      });


      // Pinta la comida
      processing.fill(204, 0, 255);
      processing.image(comida, world.food.x * dx, world.food.y * dy, dx, dy);

      // Pinta el score
      processing.fill(0, 0, 0);
      processing.textFont(processing.PFont, 18);
      processing.text("Score: " + world.score, 10, 780);
      processing.textFont(processing.PFont, 18);
      processing.text("Vidas: " + world.vida, 315, 780);

      //Pinta las vidas adicionales

      if (world.l == true) {
        return processing.image(life, world.life.x * dx, world.life.y * dy, dx, dy);
      } else {
        return 0
      }
    }


    // Esta es la función que pinta todo. Se ejecuta 60 veces por segundo. 
    // No cambie esta función. Su código debe ir en drawGame
    processing.draw = function () {
      processing.drawGame(processing.state);
      processing.state = processing.onTic(processing.state);
    };

    /**
    * Actualiza el mundo en cada tic del reloj. Retorna el nuevo estado del mundo
    */
    processing.onTic = function (world) {
      return score(collision(eatLife(eatFood(make(world, { snake: moveSnake(world.snake, world.dir) })))));
    }

    /**
    * Actualiza el mundo cada vez que se oprime una tecla. Retorna el nuevo estado del mundo
    */
    processing.onKeyEvent = function (world, keyCode) {
      switch (keyCode) {
        case processing.UP:
          if ((world.dir.x !== 0) && (world.dir.y !== 1)) {
            return make(world, { dir: { y: -1, x: 0 } });
          } else {
            return make(world, {});
          }
          break;
        case processing.DOWN:
          if ((world.dir.x !== 0) && (world.dir.y !== -1)) {
            return make(world, { dir: { y: 1, x: 0 } });
          } else {
            return make(world, {});
          }
          break;
        case processing.LEFT:
          if ((world.dir.x !== 1) && (world.dir.y !== 0)) {
            return make(world, { dir: { y: 0, x: -1 } });
          } else {
            return make(world, {});
          }
          break;
        case processing.RIGHT:
          if ((world.dir.x !== -1) && (world.dir.y !== 0)) {
            return make(world, { dir: { y: 0, x: 1 } });
          } else {
            return make(world, {});
          }
          break;
        case 87:  //W
          if ((world.dir.x !== 0) && (world.dir.y !== 1)) {
            return make(world, { dir: { y: -1, x: 0 } });
          } else {
            return make(world, {});
          }
          break;
        case 83:  //S
          if ((world.dir.x !== 0) && (world.dir.y !== -1)) {
            return make(world, { dir: { y: 1, x: 0 } });
          } else {
            return make(world, {});
          } break;
        case 65:  //A
          if ((world.dir.x !== 1) && (world.dir.y !== 0)) {
            return make(world, { dir: { y: 0, x: -1 } });
          } else {
            return make(world, {});
          } break;
        case 68:  //D
          if ((world.dir.x !== -1) && (world.dir.y !== 0)) {
            return make(world, { dir: { y: 0, x: 1 } });
          } else {
            return make(world, {})
          } break;
        case 32: //Space
          return make(world, { speed: toggleNitro(world.speed) });
          break;
        default:
          console.log(keyCode);
          return make(world, {});
      }
    }

    // Esta función se ejecuta cada vez que presionamos una tecla. 
    // No cambie esta función. Su código debe ir en onKeyEvent
    processing.keyPressed = function () {
      processing.state = processing.onKeyEvent(processing.state, processing.keyCode);
    }
  }

  var canvas = document.getElementById("canvas");

  // Adjuntamos nuestro sketch al framework de processing
  var processingInstance = new Processing(canvas, sketchProc);
</script>